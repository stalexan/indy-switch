#include "indy_mqtt.h"

#include <cJSON.h>
#include <esp_log.h>
#include <mqtt_client.h>

#include "indy_config.h"
#include "indy_json.h"
#include "indy_util.h"

// Code is based on example code from
// [ESP-MQTT SSL Sample application](https://github.com/espressif/esp-idf/tree/v5.1.1/examples/protocols/mqtt/ssl)

#pragma GCC diagnostic ignored "-Wmissing-field-initializers"

// The root cert used to create TLS client connections, from the file main/elias_alexan_org.pem
extern const uint8_t indy_pem_start[]  asm("_binary_elias_alexan_org_pem_start");
extern const uint8_t indy_pem_end[]    asm("_binary_elias_alexan_org_pem_end");

namespace {
  const char *TAG = "indy_mqtt";

  const int COMMAND_QOS = 2;
  const int ACK_QOS = 1;

  const int RESPONSES_MAX = 32;
}

// Handles events generated by the MQTT service
static void MqttEventHandler(void *handler_args, esp_event_base_t base, int32_t event_id, void *event_data) {
  esp_mqtt_event_handle_t event = (esp_mqtt_event_handle_t) event_data;
  IndyMqtt *indy_mqtt = reinterpret_cast<IndyMqtt*>(handler_args);
  switch ((esp_mqtt_event_id_t) event_id) {
  case MQTT_EVENT_CONNECTED:
    ESP_LOGI(TAG, "MQTT_EVENT_CONNECTED");
    indy_mqtt->HandleMqttConnected();
    break;
  case MQTT_EVENT_DISCONNECTED:
    ESP_LOGI(TAG, "MQTT_EVENT_DISCONNECTED");
    break;
  case MQTT_EVENT_SUBSCRIBED:
    ESP_LOGI(TAG, "MQTT_EVENT_SUBSCRIBED, msg_id=%d", event->msg_id);
    break;
  case MQTT_EVENT_UNSUBSCRIBED:
    ESP_LOGI(TAG, "MQTT_EVENT_UNSUBSCRIBED, msg_id=%d", event->msg_id);
    break;
  case MQTT_EVENT_PUBLISHED:
    ESP_LOGI(TAG, "MQTT_EVENT_PUBLISHED, msg_id=%d", event->msg_id);
    break;
  case MQTT_EVENT_DATA:
    {
      std::string topic(event->topic, event->topic_len);
      ESP_LOGI(TAG, "MQTT_EVENT_DATA for topic %s", topic.c_str());
      indy_mqtt->HandleMqttData(topic, std::string(event->data, event->data_len));
    }
    break;
  case MQTT_EVENT_ERROR:
    ESP_LOGI(TAG, "MQTT_EVENT_ERROR");
    if (event->error_handle->error_type == MQTT_ERROR_TYPE_TCP_TRANSPORT) {
      ESP_LOGI(TAG, "Last error code reported from esp-tls: 0x%x", event->error_handle->esp_tls_last_esp_err);
      ESP_LOGI(TAG, "Last tls stack error number: 0x%x", event->error_handle->esp_tls_stack_err);
      ESP_LOGI(TAG, "Last captured errno : %d (%s)",  event->error_handle->esp_transport_sock_errno,
               strerror(event->error_handle->esp_transport_sock_errno));
    } else if (event->error_handle->error_type == MQTT_ERROR_TYPE_CONNECTION_REFUSED) {
      ESP_LOGI(TAG, "Connection refused error: 0x%x", event->error_handle->connect_return_code);
    } else {
      ESP_LOGW(TAG, "Unknown error type: 0x%x", event->error_handle->error_type);
    }
    break;
  default:
    ESP_LOGI(TAG, "Other event id:%d", event->event_id);
    break;
  }
}

// Sets up this IndyMqtt
void IndyMqtt::Setup() {
  // Configure the MQTT client
  const esp_mqtt_client_config_t config = {
    .broker = {
      .address = {
        .uri = MQTT_BROKER,
      },
      .verification = {
        .certificate = (const char *) indy_pem_start
      },
    },
    .credentials = {
      .username = MQTT_USER,
      .client_id = HOSTNAME,
      .authentication = {
        .password = MQTT_PASSWORD,
      },
     },
  };
  client = esp_mqtt_client_init(&config);
  if (client == nullptr) {
    ESP_LOGE(TAG, "Initialize client failed");
    abort();
  }

  // Register the MQTT event handler
  ESP_ERROR_CHECK(esp_mqtt_client_register_event(
    client, (esp_mqtt_event_id_t) ESP_EVENT_ANY_ID, MqttEventHandler, this));

  // Start the MQTT client
  ESP_ERROR_CHECK(esp_mqtt_client_start(client));

  // Create the publish task used to send responses, so that publishing doesn't
  // block other work.
  publish_task.CreateTask(PublishTaskFunction, this);

  // Create the responses mutex
  responses_mutex = xSemaphoreCreateMutex();
  if (responses_mutex == nullptr) {
    ESP_LOGE(TAG, "Create responses mutex failed");
    abort();
  }
}

// Subscribes to the specified topic and registers the handler to call when data
// for the topic is received
void IndyMqtt::SubscribeToTopic(const char* topic, const DataHandler& handler) {
  ESP_LOGI(TAG, "Subscribing to %s", topic);
  // Subscribe
  int result = esp_mqtt_client_subscribe(client, topic, COMMAND_QOS);
  if (result == -2) {
    ESP_LOGE(TAG, "Susbcribe to %s failed: full outbox", topic);
    return;
  } else if (result <= 0) {
    ESP_LOGE(TAG, "Susbcribe to %s failed: return code %d", topic, result);
    return;
  }

  // Register handler
  dataHandlers[topic].push_back(handler);
}

// Calls the handlers that have been registered for the MQTT_EVENT_CONNECTED event
void IndyMqtt::HandleMqttConnected() {
  // Call connected handlers
  for (const ConnectedHandler& handler : connectedHandlers) {
    handler();
  }
}

// Returns an MqttResponse to return for the message `data` received for `topic`
MqttResponse IndyMqtt::GenerateMqttResponse(const std::string& topic, const std::string& data) {
  // Parse the received message JSON data
  JsonParser parser(data.c_str(), TAG, FormatString("JSON parsing failed for topic '%s'", topic.c_str()));
  std::string message = parser.Parse();
  if (message.length() > 0)
    return MqttResponse(MQTT_BAD_REQUEST, message);

  // Find the message header object
  const char *HEADER = "header";
  JsonResult<cJSON*> header = parser.GetObject(nullptr, nullptr, HEADER);
  if (header.is_error)
    return MqttResponse(MQTT_BAD_REQUEST, header.message);

  // Find the message id
  JsonResult<std::string> message_id = parser.GetString(header.value, HEADER, "message_id");
  if (message_id.is_error)
    return MqttResponse(MQTT_BAD_REQUEST, message_id.message);

  // Find the message content object
  JsonResult<cJSON *> content = parser.GetObject(nullptr, nullptr, "content");
  if (content.is_error) {
    MqttResponse response = MqttResponse(MQTT_BAD_REQUEST, content.message);
    response.SetId(message_id.value);
    return response;
  }

  // Pass the content to the data handlers, to handle the message and generate a response
  std::vector<DataHandler> handlers = dataHandlers[topic];
  MqttResponse response;
  for (const DataHandler& handler : handlers) {
    response = handler(content.value, &parser);
    response.SetId(message_id.value);
    if (!response.IsOk())
      return response;
  }

  // Return the last good response
  return response;
}

// Notifies IndyMqtt that there are responses to publish
void IndyMqtt::PublishTaskFunction(void *arg) {
  // Publish responses
  IndyMqtt* indy_mqtt = reinterpret_cast<IndyMqtt*>(arg);
  indy_mqtt->PublishResponses();
}

// Publishes responses
void IndyMqtt::PublishResponses() {
  // Acquire responses mutex
  if (xSemaphoreTake(responses_mutex, MAX_WAIT) != pdTRUE) {
    ESP_LOGE(TAG, "Failed to acquire reponses mutex for next response");
    return;
  }

  // Find responses to publish
  std::vector<MqttResponse> responses_to_publish;
  for (auto& candidate : responses) {
    if (!candidate.GetSent()) {
      // Make local copies since memory allocated for originals needs to be
      // released back on the main thread where it was allocated
      candidate.SetSent(true);
      responses_to_publish.push_back(candidate);  // Makes a local copy
    }
  }

  // Release responses mutex
  if (xSemaphoreGive(responses_mutex) != pdTRUE)
    ESP_LOGE(TAG, "Failed to release reponses mutex for next response");

  // Publish responses. The publish call might block, but just this task will be blocked.
  std::string topic = FormatString("indy-switch/%s/ack", HOSTNAME);
  for (auto& response : responses_to_publish) {
    std::string json = response.Marshal();
    int result = esp_mqtt_client_publish(client, topic.c_str(), json.c_str(), json.length(), ACK_QOS, false);
    if (result > 0) {
      ESP_LOGI(TAG, "Published %d to %s:\n%s", result, topic.c_str(), json.c_str());
    } else {
      std::string message = FormatString("Publish to %s failed:", topic.c_str());
      if (result == -2)
        message += " full outbox:";
      message += FormatString("\n%s", json.c_str());
      ESP_LOGE(TAG, "%s", message.c_str());
    }
  }
}

// Handles the MQTT_EVENT_DATA event
void IndyMqtt::HandleMqttData(const std::string& topic, const std::string& data) {
  // Generate a response
  MqttResponse response = GenerateMqttResponse(topic, data);

  // Acquire the responses mutex
  if (xSemaphoreTake(responses_mutex, MAX_WAIT) != pdTRUE) {
    ESP_LOGE(TAG, "%s", response.CreateErrorMessage("Failed to acquire reponses mutex").c_str());
    return;
  }

  // Clean up any past responses
  for (auto it = responses.begin(); it != responses.end() && it->GetSent();) {
    ESP_LOGI(TAG, "Removing sent response '%s' from responses queue", it->GetId().c_str());
    it = responses.erase(it);
  }

  // Add new response to responses queue. Limit size of queue since entries are later
  // placed on task stack which is limited to TASK_STACK_DEPTH bytes.
  if (responses.size() < RESPONSES_MAX) {
    responses.push_back(response);
  } else {
    std::string prefix = FormatString(
      "Unable to queue response for send because response queue has reached max size %d", RESPONSES_MAX);
    ESP_LOGE(TAG, "%s", response.CreateErrorMessage(prefix).c_str());
  }

  // Release the responses mutex
  if (xSemaphoreGive(responses_mutex) != pdTRUE)
    ESP_LOGE(TAG, "%s", response.CreateErrorMessage("Failed to release reponses mutex").c_str());

  // Notify task that there's a response to publish
  publish_task.TaskNotifyGive();
}

// Returns an error message for the response, that is `prefix` followed by the
// responses `id` if it has one.
std::string MqttResponse::CreateErrorMessage(const std::string& prefix) {
  if (id.length() > 0)
    return FormatString("%s for response %s", prefix.c_str(), id.c_str());
  return prefix;
}

// Adds any JSON for content to `json`
void MqttResponse::AddContentToJson(cJSON *json) {
  // Is there content to add?
  if (content == "")
    return;

  // Parse content
  cJSON *content_json = cJSON_Parse(content.c_str());
  if (!content_json) {
      ESP_LOGE(TAG, "Failed to parse response content '%s'", content.c_str());
      return;
  }

  // Add content
  if (!cJSON_AddItemToObject(json, "content", content_json)) {
    ESP_LOGE(TAG, "Failed to add content JSON to response");
    cJSON_Delete(content_json);
  }
}

// Returns the JSON for this response. Should only be called once if content is
// not null, since content ownership is given to json and cleaned up.
std::string MqttResponse::Marshal() {
  // Create JSON
  cJSON *json = cJSON_CreateObject();
  cJSON_AddStringToObject(json, "id", id.c_str());
  cJSON_AddNumberToObject(json, "status_code", status_code);
  cJSON_AddStringToObject(json, "message", message.c_str());
  AddContentToJson(json);

  // Create string
  char *json_str = cJSON_Print(json);
  std::string result(json_str);

  // Clean up
  cJSON_Delete(json);
  free(json_str);

  return result;
}
